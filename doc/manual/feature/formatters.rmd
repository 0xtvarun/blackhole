#Formatters

Formatters are entities that map log event to string. Blackhole supports three
built-in formatters:

  * [String](#string). Maps log event to plain string by specified pattern with
  attributes support.
  * [JSON](#json). Maps log event to JSON tree.
  * [Msgpack](#msgpack). Maps log event to message-packed tree.

## String
Maps log event to plain string by specified pattern with attributes support.

### Registration
When we register **string** formatter with some sink `string_t` should be used.

For example:

~~~ cpp
repository_t::instance().configure<
    sink::syslog_t<level>,
    formatter::string_t
>();
~~~

This code register **syslog** sink and **string** formatter pair. How to
register another combinations of sinks and formatters check the
[registration rules]() article.

### Configuration

Typical configuration looks like:

~~~ cpp
formatter_config_t formatter("string");
formatter["pattern"] = "[%(timestamp)s] [%(severity)s]: %(message)s";
~~~

The only parameter of the formatter is **pattern**. In this field we set the
common view of log message.

**Pattern** consists of two types of entities. The first one is arbitrary
symbols and the second type is placeholders.

BNF syntax for **pattern**:

~~~ bnf
pattern  ::= ( literal | rph | oph | vph )+
literal  ::= char+
rph      ::= '%(' alnum+ ')s'
oph      ::= '%(' [char]* '[' alnum+ ']' [char]* ')?s'
vph      ::= '%(...' ( 'L' | 'E' | 'G' | 'T' | 'U' )+ ')s'
alnum    ::= :alnum:
num      ::= ‘0’ | ‘1’ | ‘2’ | ‘3’ | ‘4’ | ‘5’ | ‘6’ | ‘7’ | ‘8’ | ‘9’
~~~

Tokens **rph**, **oph** and **vph** are placeholders of three types which are
processed in different manner.

#### Required placeholders

Syntax:

~~~ bnf
%(' alnum+ ')s
~~~

For example these are well known for us placeholder `%(timestamp)s`,
`%(severity)s` and `%(message)s`.

This type of placeholder requires the same named attributes of log message.
For macro `ВН_LOG` `severity` and `message` are the second and third parameter
correspondingly. The `timestamp` is generated inside the logging system.

~~~ cpp
BH_LOG(log, severity, "message");
~~~

Logger doesn't raise an exception on missing attributes while `BH_LOG` call,
instead, it sends warn message to standard output.

#### Optional placeholders

Syntax:

~~~ bnf
%(' [char]* '[' alnum+ ']' [char]* ')?s
~~~

This placeholder doesn't require attribute in log message. If log message
doesn't contain necessary attribute all of the content inside parenthesis will
be skipped.

Let's consider the next pattern:

~~~ cpp
formatter["pattern"] = "outer_symbols-%(inner_symbols<[optional_attr]>inner_symbols)?s-outer_symbols";
~~~

Calling of

~~~ cpp
BH_LOG(log, 0, "");
~~~
will produce the next output string

```
outer_symbols--outer_symbols
```

Calling of
~~~ cpp
BH_LOG(log, 0, "")("optional_attr","attr_value");
~~~

will produce the next output string

```
outer_symbols-inner_symbols<attr_value>inner_symbols-outer_symbols
```

#### Variadic placeholders

Syntax:

~~~ bnf
'%(...' ( 'L' | 'E' | 'G' | 'T' | 'U' )+ ')s'
~~~

'L', 'E', 'G', 'T', 'U' are the types of attributes.

Attributes `"timestamp"`, `"severity"` and `"message"` have 'E'-type. All other
attributes have 'L'-type by default. How to set the type of attribute you
can read in the ["special"]() article.

This placeholder get all of the attributes of log message of specified type and
insert them into the final string in the next manner:

```
???
```

### Example
In development.

## JSON
Maps log event to JSON tree. It takes attributes of log message and represents
this `attribute_name=attribute_value` pair into JSON objects.

For example:

~~~ cpp
BH_LOG(log, severity, "message")("attr1", "val1", "attr2", "val2");
~~~

produces

~~~ json
{
    "timestamp":time,
    "severity":severity,
    "message":"text",
    "attr1":"val1",
    "attr2","val2"
}
~~~

Using configuration parameters for this formatter you can

    * Rename parameters;
    * Construct hierarchical tree.


Include the special header

~~~ cpp
#include <blackhole/formatter/json.hpp>
~~~

### Registration
When we register **json** formatter with some sink `json_t` should be used.
For example:

~~~ cpp
repository_t::instance().configure<sink::syslog_t<level>, formatter::json_t>();
~~~

This code register **syslog** sink and **json** formatter pair. How to register
another combinations of sinks and formatters check the
["Registration rules"]() article.

### Configuration

Example of configuration

~~~ cpp
formatter_config_t formatter("json");
formatter["newline"] = true;
formatter["mapping"]["message"] = "@message";
formatter["mapping"]["timestamp"] = "@timestamp";
formatter["routing"]["/"] = dynamic_t::array_t { "message", "timestamp" };
formatter["routing"]["/fields"] = "*";
~~~

  * `newline` - The newline symbol will be added to the end of final string if
  `true`.
  * `mapping` - This property is used to rename attributes. For example setting
  `formatter["mapping"]["message"] = "@message";` leads to object
  {"@message":"text"} istead of {"message":"text"}.
  * `routing` - This property is used for tree formatting.

If we will call `BH_LOG` with the settings as shown above

~~~ cpp
BH_LOG(log, level::debug, "debug event")("host", "127.0.0.1", "issue", "training");
~~~

The next output will be produced

~~~ json
{
    "@message":"debug event",
    "@timestamp":"time",
    "fields":{
        "host":"127.0.0.1",
        "issue":"training"
    },
}
~~~

### Example
In development.

## Msgpack
This formatter get pairs of `attribute_name:attribute_value` and convert it to
the msgpack object.

### Registration
When we register `msgpack`-formatter with some sink `msgpack_t` should be used.
For example:

~~~ cpp
repository_t::instance().configure<sink::syslog_t<level>, formatter::msgpack_t>();
~~~

### Configuration

It doesn't have any configuration parameter and you just need to type formatter
as "msgpack"

~~~ cpp
formatter_config_t formatter("msgpack");
~~~

### Example
In development.
